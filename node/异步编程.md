## 异步编程

##### 回调函数

不成立情况：

```javascript
function add(x,y){
    console.log(1)
    setTimeout(function(){
        console.log(2)
        let ret = x + y
        return ret
    },1000)
    console.log(3)
    // 到这里执行就结束了，不会等到前面的定时器，所以直接就返回默认值undefined
}

console.log(add(10,20)) // => undefined
```

不成立情况：

```javascript
function add(x,y){
    let ret
    console.log(1)
    setTimeout(function(){
        console.log(2)
        ret = x + y
        return ret
    },1000)
    console.log(3)
    return ret
}

console.log(add(10,20)) // => undefined
```

回调函数：

```javascript
function add(x,y,callback){
    // callback 就是回调函数
    // let x = 10
    // let y = 20
    // let callback = function (ret) { console.log(ret) }
    console.log(1)
    setTimeout(function(){
        let ret = x + y
        callback(ret)
    },1000)
}

add(10,20,function(ret){
    console.log(ret)
})
```

基于原生 XMLHTTPRequest 封装 get 方法：

```javascript
function get(url,callback){
    let oReq = new XMLHttpRequest()
    // 当请求加载成功之后要调用指定的函数
    oReq.onload = function(){
        // 需要得到这里的 oReq.responseText
        callback(oReq.responseText)
    }
    oReq.open('get',url,true)
    oReq.send()
}

get('data.json',function(data){
    console.log(data)
})
```

##### Promise

参考文档： [https://es6.ruanyifeng.com/#docs/promise](https://es6.ruanyifeng.com/#docs/promise)

callback hell:

![下载](C:\Users\z1760\Desktop\下载.jpg)

为了解决回调地狱，EcmaScript6 中新增了一个 API ： `Promise`

```javascript
const fs = require('fs')

let p1 = new Promise((resolve,reject) => {
	fs.readFile('./data/a.txt','utf8',(err,data) => {
		if(err) {
			reject(err)
		} else {
			resolve(data)
		}
	})
})

let p2 = new Promise((resolve,reject) => {
	fs.readFile('./data/b.txt','utf8',(err,data) => {
		if(err) {
			reject(err)
		} else {
			resolve(data)
		}
	})
})

let p3 = new Promise((resolve,reject) => {
	fs.readFile('./data/c.txt','utf8',(err,data) => {
		if(err) {
			reject(err)
		} else {
			resolve(data)
		}
	})
})

p1
	.then(data => {
		console.log(data)
		return p2
	},err => {
		console.log('读取文件失败',err)
	})
	.then(data => {
		console.log(data)
		return p3
	})
	.then(data => {
		console.log(data)
	})
```

封装 Promise 版本的 `readFile`:

```javascript
const fs = require('fs')

let pReadFile = filePath => {
	return new Promise((resolve,reject) => {
	fs.readFile(filePath,'utf8',(err,data) => {
		if(err) {
			reject(err)
		} else {
			resolve(data)
		}
	})
})
}

pReadFile('./data/a.txt')
	.then(data => {
		console.log(data)
		return pReadFile('./data/b.txt')
	})
	.then(data => {
		console.log(data)
		return pReadFile('./data/c.txt')
	})
	.then(data => {
		console.log(data)
	})
```

